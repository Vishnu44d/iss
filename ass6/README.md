# Assignment 6

## Problems

- ## Part 1 ---------------

  MD4 is a hash function built on the principle of Merkle Dåmgard Construction.

  Implement MD4.

  Refer to appropriate text for executive summary.
  You may refer to the following RFC (An RFC (Request for Comments) is documentation, published by the IETF and ISoc, standardizing technical development protocols and procedures):
  RFC 1320 (https://tools.ietf.org/html/rfc1320)

- ## Part 2 ---------------

  1. Design a Digital Signature protocol using RSA algorithm.

  2. Create a hash of the message (using SHA or MD4), and digitally sign the hash of the digest. Send the message and the digest to the recipient. Use your KYC document, from last assignment here as the message.

  3. Verify appropriately at the receiver end. To Specify:

  - Sender side: D = hash(M), S = digitalSign(D) using sender’s private key, send(M,S)

  - Receiver side: D = hash(M), retrieve digest from S: D’ = decode(S) using sender’s public key, match D and D’, if they are equivalent accept M, else reject M. Set up a network with 5 users and a Trusted Third Party (TTP).

  Note: digitalSign() and decode() functions above, are nothing but RSA encryption and decryption,
  respectively.

- ## Part 3 ---------------

  1. Set up a network with 5 users and a Trusted Third Party (TTP), whom all users trust. Each user and the TTP holds a private, public RSA key pair. (Generate the keys for all 6 nodes, and broadcast all public keys within the network.)

  2. Every user has to register with the TTP before she can start communication over the network. (Assume password based registration and authentication. Every user is assigned a unique id, and a password generated by the TTP, which she would use for subsequent logging in before using the network).

  3. For reliable transmission of a message from user A to user B, first the TTP verifies A, for which A has to successfully login.

  4. Then, A sends the message, sender id, and receiver id to the TTP, along with her digital signature.

  5. The digital signature is verified by the TTP, and a copy of the message is saved with the TTP, so that later A cannot deny sending it.

  6. Extracting information about the receiver (B’s id), the TTP now creates its own signature from the message, and sends the message, sender id, receiver id, the new signature and a timestamp to B.

  7. B verifies the message using the public key of the TTP.

---

## Solutions

- ## Part 1 ---------------

  1. MD4.c implements the MD4 algorithm.

  2. It reads from KYC.txt and prints its' digest (MD4) in the console.

  3. To run the code.

  ```bash
  1. gcc -o MD4 MD4.c
  2. ./MD4
  ```

- ## Part 2 ---------------

  1. Since the implementation of this perticular problem requires to use both the codes RSA.c (From ./../ass5/ directory) as well as MD4.c (From current directory). Implementing all these in a single file would make the file very large. So two header files are created namely "RSA.h" and "MD4.h" to contain all the functions required for this problem.

  2. hashAndSign.c implements this solution. Firstly it includes files "RSA.h" for functionalities of RSA and then it inclued "MD4.h" for the functionalities MD4.

  3. It then reads the KYC.txt and using MD4 craetes a digest in digest.txt.

  4. Then it loads the private key (d, n) from "privatekey.txt".

  5. Then it sign this digest using RSA signature, and produces signature.txt.

  6. Now it asumes that these two files signature.txt and digest.txt is sent over a insecure network. And the following steps are performed in reciever's compueter.

  7. It load the public key (e, n) from the file publickey.txt.

  8. It loads the signature.txt and decode it using the public key (e, n).

  9. It loads the digest.txt and compares its' content with the decrypted message in previos step.

  10. If both are same, then accept the digest othewise reject it.

  11. To run the code

  ```bash
  1. gcc -o hashAndSign hashAndSign.c
  2. ./hashAndSign
  ```

- ## Part 3 ---------------

  1. The directory ReliableNetwork contains the flow and execution of this part.

  2. Currently incomplete.

  3. Created a network using socket where a server acts as a TTP.

  4. Created a client using socket whic acts as the users. This client can be run in different terminal to act as different clients.

  5. All clients can connect with the server. And can securly send the data to server.

  6. At server, different clients are handled using fork() and creating a new process for each one client.

  7. In the next step of implementation, the server should access other clients in a process of one client. This leads to rise the problem of reader and writes for sharing and accessing common list (list of all clients.).
